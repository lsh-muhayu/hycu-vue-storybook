import{i as D,p as R,F as W,j as y,f as T,V as L,W as V,x as I,M as P,r as b,e as A,X as k,k as B,l as G,d as j,P as z,h as M,Y as J,y as Y,Z as q}from"./iframe-D0s_mCcR.js";function se(t,e){const o=typeof t=="string"&&!e?`${t}Context`:e,n=Symbol(o);return[i=>{const u=D(n,i);if(u||u===null)return u;throw new Error(`Injection \`${n.toString()}\` not found. Component must be used within ${Array.isArray(t)?`one of the following components: ${t.join(", ")}`:`\`${t}\``}`)},i=>(R(n,i),i)]}function _(t){return t?t.flatMap(e=>e.type===W?_(e.children):[e]):[]}function K(t){return L()?(V(t),!0):!1}const $=typeof window<"u"&&typeof document<"u";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const X=t=>typeof t<"u",F=()=>{};function Z(t,e){function o(...n){return new Promise((a,r)=>{Promise.resolve(t(()=>e.apply(this,n),{fn:e,thisArg:this,args:n})).then(a).catch(r)})}return o}function H(t,e={}){let o,n,a=F;const r=c=>{clearTimeout(c),a(),a=F};let i;return c=>{const f=T(t),s=T(e.maxWait);return o&&r(o),f<=0||s!==void 0&&s<=0?(n&&(r(n),n=null),Promise.resolve(c())):new Promise((d,v)=>{a=e.rejectOnCancel?v:d,i=c,s&&!n&&(n=setTimeout(()=>{o&&r(o),n=null,d(i())},s)),o=setTimeout(()=>{n&&r(n),n=null,d(c())},f)})}}function ue(t,e=200,o={}){return Z(H(e,o),t)}function le(t,e,o){const n=y(t,(...a)=>(I(()=>n()),e(...a)),o);return n}const U=$?window:void 0;function C(t){var e;const o=T(t);return(e=o?.$el)!=null?e:o}function Q(){const t=k(!1),e=P();return e&&B(()=>{t.value=!0},e),t}function ee(t){const e=Q();return A(()=>(e.value,!!t()))}function te(t){return JSON.parse(JSON.stringify(t))}function ce(t,e,o={}){const{window:n=U,...a}=o;let r;const i=ee(()=>n&&"ResizeObserver"in n),u=()=>{r&&(r.disconnect(),r=void 0)},c=A(()=>{const d=T(t);return Array.isArray(d)?d.map(v=>C(v)):[C(d)]}),f=y(c,d=>{if(u(),i.value&&n){r=new ResizeObserver(e);for(const v of d)v&&r.observe(v,a)}},{immediate:!0,flush:"post"}),s=()=>{u(),f()};return K(s),{isSupported:i,stop:s}}function fe(t,e,o,n={}){var a,r,i;const{clone:u=!1,passive:c=!1,eventName:f,deep:s=!1,defaultValue:d,shouldEmit:v}=n,h=P(),O=o||h?.emit||((a=h?.$emit)==null?void 0:a.bind(h))||((i=(r=h?.proxy)==null?void 0:r.$emit)==null?void 0:i.bind(h?.proxy));let N=f;N=N||`update:${e.toString()}`;const l=m=>u?typeof u=="function"?u(m):te(m):m,p=()=>X(t[e])?l(t[e]):d,w=m=>{v?v(m)&&O(N,m):O(N,m)};if(c){const m=p(),g=b(m);let S=!1;return y(()=>t[e],E=>{S||(S=!0,g.value=l(E),I(()=>S=!1))}),y(g,E=>{!S&&(E!==t[e]||s)&&w(E)},{deep:s}),g}else return A({get(){return p()},set(m){w(m)}})}function de(){const t=P(),e=b(),o=A(()=>["#text","#comment"].includes(e.value?.$el.nodeName)?e.value?.$el.nextElementSibling:C(e)),n=Object.assign({},t.exposed),a={};for(const i in t.props)Object.defineProperty(a,i,{enumerable:!0,configurable:!0,get:()=>t.props[i]});if(Object.keys(n).length>0)for(const i in n)Object.defineProperty(a,i,{enumerable:!0,configurable:!0,get:()=>n[i]});Object.defineProperty(a,"$el",{enumerable:!0,configurable:!0,get:()=>t.vnode.el}),t.exposed=a;function r(i){e.value=i,i&&(Object.defineProperty(a,"$el",{enumerable:!0,configurable:!0,get:()=>i instanceof Element?i:i.$el}),t.exposed=a)}return{forwardRef:r,currentRef:e,currentElement:o}}function ne(t,e){const o=b(t);function n(r){return e[o.value][r]??o.value}return{state:o,dispatch:r=>{o.value=n(r)}}}function oe(t,e){const o=b({}),n=b("none"),a=b(t),r=t.value?"mounted":"unmounted";let i;const u=e.value?.ownerDocument.defaultView??U,{state:c,dispatch:f}=ne(r,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),s=l=>{if($){const p=new CustomEvent(l,{bubbles:!1,cancelable:!1});e.value?.dispatchEvent(p)}};y(t,async(l,p)=>{const w=p!==l;if(await I(),w){const m=n.value,g=x(e.value);l?(f("MOUNT"),s("enter"),g==="none"&&s("after-enter")):g==="none"||g==="undefined"||o.value?.display==="none"?(f("UNMOUNT"),s("leave"),s("after-leave")):p&&m!==g?(f("ANIMATION_OUT"),s("leave")):(f("UNMOUNT"),s("after-leave"))}},{immediate:!0});const d=l=>{const p=x(e.value),w=p.includes(CSS.escape(l.animationName)),m=c.value==="mounted"?"enter":"leave";if(l.target===e.value&&w&&(s(`after-${m}`),f("ANIMATION_END"),!a.value)){const g=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",i=u?.setTimeout(()=>{e.value?.style.animationFillMode==="forwards"&&(e.value.style.animationFillMode=g)})}l.target===e.value&&p==="none"&&f("ANIMATION_END")},v=l=>{l.target===e.value&&(n.value=x(e.value))},h=y(e,(l,p)=>{l?(o.value=getComputedStyle(l),l.addEventListener("animationstart",v),l.addEventListener("animationcancel",d),l.addEventListener("animationend",d)):(f("ANIMATION_END"),i!==void 0&&u?.clearTimeout(i),p?.removeEventListener("animationstart",v),p?.removeEventListener("animationcancel",d),p?.removeEventListener("animationend",d))},{immediate:!0}),O=y(c,()=>{const l=x(e.value);n.value=c.value==="mounted"?l:"none"});return G(()=>{h(),O()}),{isPresent:A(()=>["mounted","unmountSuspended"].includes(c.value))}}function x(t){return t&&getComputedStyle(t).animationName||"none"}var me=j({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(t,{slots:e,expose:o}){const{present:n,forceMount:a}=z(t),r=b(),{isPresent:i}=oe(n,r);o({present:i});let u=e.default({present:i.value});u=_(u||[]);const c=P();if(u&&u?.length>1){const f=c?.parent?.type.name?`<${c.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${f}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(s=>`  - ${s}`).join(`
`)].join(`
`))}return()=>a.value||n.value||i.value?M(e.default({present:i.value})[0],{ref:f=>{const s=C(f);return typeof s?.hasAttribute>"u"||(s?.hasAttribute("data-reka-popper-content-wrapper")?r.value=s.firstElementChild:r.value=s),s}}):null}});const ie=j({name:"PrimitiveSlot",inheritAttrs:!1,setup(t,{attrs:e,slots:o}){return()=>{if(!o.default)return null;const n=_(o.default()),a=n.findIndex(c=>c.type!==J);if(a===-1)return n;const r=n[a];delete r.props?.ref;const i=r.props?Y(e,r.props):e,u=q({...r,props:{}},i);return n.length===1?u:(n[a]=u,n)}}}),re=["area","img","input"],pe=j({name:"Primitive",inheritAttrs:!1,props:{asChild:{type:Boolean,default:!1},as:{type:[String,Object],default:"div"}},setup(t,{attrs:e,slots:o}){const n=t.asChild?"template":t.as;return typeof n=="string"&&re.includes(n)?()=>M(n,e):n!=="template"?()=>M(t.as,e,{default:o.default}):()=>M(ie,e,{default:o.default})}});export{pe as P,ie as S,de as a,fe as b,se as c,me as d,ue as e,ce as f,ne as g,C as u,le as w};
